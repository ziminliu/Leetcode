# [240.搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)
# [面试题04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)
官方题目如下：  
在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
示例:

现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。

给定 target = 20，返回 false。
限制：

0 <= n <= 1000

0 <= m <= 1000

笔者思路：  
当我看到这题时，相信很多人想到的思路都和我一样就是 `折半查找` , 只需要判断matrix[i][i]的`value` 与`target` 的值进行比较，然后把矩阵的查找范围不断减小，但是后来发现这样不行，这种情况只能用于特定的场合，如`matrix[i][i] < matrix[0][i+1]&&matrix[i][i] < matrix[i+1][0]`,一旦在下列这种情况下就不会适用
[
  [1,   4,  7,  8, 15],
  [2,   5,  7, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
当我们采用以上思路时，`target = 8`,目标就会先与`matrix[2][2]` 比较，发现目标值小于9，就会将目标区域锁定在3*3的矩阵中，显然这样就漏掉了`8`，返回错误的值。正确的思路应该是：  
根据给定矩阵的特性，我们可以发现，每一行(列)的第一个元素都是该行(列)的最小值，假设我们定义一个变量`right`来指向矩阵的最右列的第一个值，倘若这个值，以上例子中`right = 15`，我们将`right`与`target` 比较，如果`right`大于`target`，那么，目标值定然不会存在于此列中，我们就可以将`right--`,然后再次比较他们的值，依次缩小目标区域。  

同理，根据上面`right`的思路，我们又可以设置一个个`bottom`变量，对矩阵的行的删减，以减少对无意义数据的判断。

解决方式如下：  
1. 设置两个变量`right` 和`bottom` 分别记录矩阵右上和左下元素的值。
2. 设置一个循环，用于得到需要查找的区域，循环内部使用`if` 判断条件，不断减小`right` 和`bottom`的值
3. 经过初步得到的矩阵，我们此时的`right` 和`bottom`都处于一个最大的临界值，同样，还是根据矩阵的特性，如果我们判断出`matrix[bottom][right]<target`,那么我们此时就可以直接返回`false`,因为在当前经过筛选的矩阵中，`matrix[bottom][right]`已经是当前矩阵的最大值了。先判断特殊情形，然后我们在判断`bottom`行上的数据，与`right`列上的数据，即需要设置两个循环。
   1. 记录当前bottom的值，在列上设置循环遍历
   2. 记录当前right的值，在行上设置循环遍历

4. 我们在两个子循环中设置判断条件，何时返回false，何时结束本次循环，何时返回true，相信大家都已经根据矩阵特性能够总结出来，那就来说说我在提交此题中遇到的一些问题吧。  

特殊值：
1.  `matrix`=`[]`
    1.  由于我之间写的程序，针对的是给的测试用例而编写的代码，一旦用例多了起来，`bug` 就应运而生了，因为你永远不知道用户会输入什么 `:(`,空就是一个特列，于是我就在开头添加了判断`matrix.length`的长度。

2.  `matrix`=`[[]]`
    1.  果然大意失荆州，判断了`matrix.length`的长度，却没有判断`matrix[0].length` 的长度，果然，我还是太菜了，呜呜呜。

3.  `matrix=[[-5]] target=-10`
    1.  这里`target`比矩阵中唯一的一个值还要小，本来得到的`bottom`和`right`就等于0,再减减操作就要小于0了，光顾着缩小矩阵范围，结果给整个负数出来了，我的解决方法是价格判断，如果`bottom`和`right`二者其中有一个小于0 那么就返回`false`

最后：二维数组的操作实际上可以依靠数组的特性将遍历从二重循环转化为一重循环，但操作的变量数是不变的，感兴趣的同学可以在我的基础上进行优化，还有，我看评论有人说从右上角看这个矩阵其实就像是一个Binary Search Tree，个人感觉个别情况下是符合的，但是好像当特殊测试用例下不满足，感兴趣的同学可以思考一下这种方法。